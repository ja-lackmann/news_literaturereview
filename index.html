<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mediaâ€“Politics Literature Review</title>

    <!-- â”€â”€ Google Fonts â”€â”€ -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
        rel="stylesheet" />

    <!-- â”€â”€ Libraries â”€â”€ -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       RESET & BASE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg: #0d1117;
            --surface: #161b22;
            --surface2: #21262d;
            --border: #30363d;
            --accent: #58a6ff;
            --accent2: #bc8cff;
            --accent3: #3fb950;
            --text: #e6edf3;
            --text-muted: #8b949e;
            --danger: #f85149;
            --node-media: #1f6feb;
            --node-people: #388bfd;
            --node-polv: #bc8cff;
            --node-custom: #3fb950;
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            --radius: 10px;
            --font: 'Inter', sans-serif;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            background: var(--bg);
            color: var(--text);
            font-family: var(--font);
            overflow: hidden;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TOOLBAR
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #toolbar {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-family: var(--font);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s, transform 0.1s;
        }

        .btn:hover {
            background: var(--surface2);
            border-color: var(--accent);
        }

        .btn:active {
            transform: scale(0.97);
        }

        .btn.primary {
            background: var(--accent);
            border-color: var(--accent);
            color: #0d1117;
        }

        .btn.primary:hover {
            background: #79b8ff;
            border-color: #79b8ff;
        }

        .btn.danger {
            border-color: var(--danger);
            color: var(--danger);
        }

        #add-edge-btn.active {
            background: #1f6feb33;
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Group Container styling */
        .group-rect {
            fill: rgba(31, 111, 235, 0.05);
            stroke: #1f6feb;
            stroke-dasharray: 4;
            stroke-width: 1.5;
            rx: 12;
            ry: 12;
            /* pointer-events handled by JS element attribute */
        }

        .group-label {
            fill: #1f6feb;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            pointer-events: none;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       USER SELECTOR (top-right)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #user-bar {
            position: fixed;
            top: 16px;
            right: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
        }

        #user-bar label {
            font-size: 12px;
            color: var(--text-muted);
        }

        #user-select {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-family: var(--font);
            font-size: 13px;
            padding: 8px 12px;
            cursor: pointer;
            min-width: 180px;
            transition: border-color 0.2s;
        }

        #user-select:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SVG CANVAS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #graph-svg {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* Node circles */
        .node-circle {
            stroke-width: 2.5;
            cursor: pointer;
            transition: filter 0.2s;
            filter: drop-shadow(0 0 8px rgba(88, 166, 255, 0.3));
        }

        .node-circle:hover {
            filter: drop-shadow(0 0 16px rgba(88, 166, 255, 0.7));
        }

        .node-label {
            fill: #e6edf3;
            font-family: var(--font);
            font-size: 13px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            user-select: none;
        }

        /* Edges */
        .edge-path {
            fill: none;
            stroke: #58a6ff;
            stroke-linecap: butt;
            /* Prevents stroke from extending past coordinates */
            cursor: pointer;
            transition: stroke 0.2s, opacity 0.2s;
            opacity: 0.75;
        }

        .edge-path:hover {
            stroke: #79b8ff;
            opacity: 1;
        }

        .edge-path.adding-edge-hover {
            stroke: #3fb950;
            opacity: 1;
        }

        .edge-label {
            fill: var(--text-muted);
            font-family: var(--font);
            font-size: 11px;
            font-weight: 500;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            user-select: none;
        }

        /* Arrows */
        marker path {
            fill: #58a6ff;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MODAL OVERLAY
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(13, 17, 23, 0.85);
            backdrop-filter: blur(4px);
            z-index: 200;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 28px;
            width: 560px;
            max-width: 95vw;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow);
            animation: slideUp 0.2s ease;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 700;
        }

        .modal-subtitle {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 3px;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 22px;
            cursor: pointer;
            line-height: 1;
            padding: 2px 6px;
            border-radius: 6px;
            transition: color 0.2s, background 0.2s;
        }

        .modal-close:hover {
            color: var(--text);
            background: var(--surface2);
        }

        /* Paper cards */
        .paper-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .paper-card {
            background: var(--surface2);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 14px 16px;
        }

        .paper-card-blurb {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 8px;
            padding: 4px 8px;
            /* Added for border breathing room */
            border: 2px solid transparent;
            /* Placeholder */
            border-radius: 6px;
        }

        .paper-card-blurb.relevance-Medium {
            border-color: #a3d1ff;
            /* light blue */
            background: rgba(163, 209, 255, 0.05);
        }

        .paper-card-blurb.relevance-High {
            border-color: #3399ff;
            /* slightly darker blue */
            border-width: 3px;
            background: rgba(51, 153, 255, 0.08);
        }

        .paper-card-meta {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .paper-card-meta a {
            color: var(--accent);
            text-decoration: none;
        }

        .paper-card-meta a:hover {
            text-decoration: underline;
        }

        .paper-empty {
            text-align: center;
            padding: 24px;
            color: var(--text-muted);
            font-size: 14px;
        }

        /* Add paper form inline */
        .add-paper-toggle {
            width: 100%;
            justify-content: center;
        }

        .add-paper-form {
            display: none;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }

        .add-paper-form.open {
            display: block;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       FORMS (modal + panel)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .form-group {
            margin-bottom: 14px;
        }

        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.06em;
            margin-bottom: 6px;
        }

        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-family: var(--font);
            font-size: 14px;
            padding: 9px 12px;
            transition: border-color 0.2s;
        }

        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        .form-textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-select {
            cursor: pointer;
        }

        .form-file-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 20px;
            font-size: 13px;
            color: var(--text-muted);
            cursor: pointer;
            transition: border-color 0.2s, color 0.2s;
        }

        .form-file-label:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .form-file-label input {
            display: none;
        }

        #file-name-display {
            font-size: 12px;
            color: var(--accent3);
            margin-top: 4px;
        }

        .form-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 16px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SIDE PANELS (Add Node / Add Edge)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .side-panel {
            display: none;
            position: fixed;
            top: 64px;
            left: 16px;
            width: 300px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 20px;
            box-shadow: var(--shadow);
            z-index: 150;
            animation: slideUp 0.2s ease;
        }

        .side-panel.open {
            display: block;
        }

        .side-panel h3 {
            font-size: 15px;
            font-weight: 700;
            margin-bottom: 16px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BAR CHART (bottom-right)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #chart-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 280px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 16px;
            box-shadow: var(--shadow);
            z-index: 100;
        }

        #chart-panel h4 {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--text-muted);
            margin-bottom: 12px;
        }

        #contrib-chart {
            max-height: 160px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       LOADING / STATUS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #status-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--surface2);
            border: 1px solid var(--border);
            border-radius: 99px;
            padding: 8px 20px;
            font-size: 13px;
            color: var(--text-muted);
            z-index: 300;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #status-bar.show {
            opacity: 1;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TOOLTIP
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #tooltip {
            position: fixed;
            background: var(--surface2);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 12px;
            pointer-events: none;
            z-index: 400;
            display: none;
        }
    </style>
</head>

<body>

    <!-- â”€â”€ HEADER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <header
        style="text-align: center; padding: 20px 0; background: var(--surface); border-bottom: 1px solid var(--border);">
        <h1 style="margin: 0; font-family: var(--font); color: var(--text); font-size: 24px; letter-spacing: -0.5px;">
            The Fight for Political Accountability</h1>
    </header>

    <!-- â”€â”€ TOOLBAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div id="toolbar">
        <button class="btn primary" id="add-node-btn">ï¼‹ Node</button>
        <button class="btn" id="add-edge-btn">ï¼‹ Edge</button>
        <button class="btn danger" id="reset-graph-btn" title="Remove all custom nodes and edges">&#x2715; Reset Custom
            Nodes</button>
    </div>

    <!-- â”€â”€ USER BAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div id="user-bar">
        <label for="user-select">You are:</label>
        <select id="user-select">
            <option value="">â€” select your name â€”</option>
        </select>
    </div>

    <!-- â”€â”€ GRAPH CANVAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <svg id="graph-svg">
        <defs>
            <!-- 5 sizes for smooth scaling (userSpaceOnUse to stop distortion) -->
            <!-- Flat bases (M0,X -> L0,Y) combined with refX=0 precisely covers wide butt lines -->
            <marker id="arrow-xs" markerWidth="14" markerHeight="14" refX="0" refY="7" orient="auto"
                markerUnits="userSpaceOnUse" viewBox="0 0 14 14">
                <path d="M0,2 L14,7 L0,12 Z" fill="#58a6ff" />
            </marker>
            <marker id="arrow-s" markerWidth="18" markerHeight="18" refX="0" refY="9" orient="auto"
                markerUnits="userSpaceOnUse" viewBox="0 0 18 18">
                <path d="M0,2 L18,9 L0,16 Z" fill="#58a6ff" />
            </marker>
            <marker id="arrow-m" markerWidth="24" markerHeight="24" refX="0" refY="12" orient="auto"
                markerUnits="userSpaceOnUse" viewBox="0 0 24 24">
                <path d="M0,2 L24,12 L0,22 Z" fill="#58a6ff" />
            </marker>
            <marker id="arrow-l" markerWidth="30" markerHeight="30" refX="0" refY="15" orient="auto"
                markerUnits="userSpaceOnUse" viewBox="0 0 30 30">
                <path d="M0,1 L30,15 L0,29 Z" fill="#58a6ff" />
            </marker>
            <marker id="arrow-xl" markerWidth="40" markerHeight="40" refX="0" refY="20" orient="auto"
                markerUnits="userSpaceOnUse" viewBox="0 0 40 40">
                <path d="M0,0 L40,20 L0,40 Z" fill="#58a6ff" />
            </marker>

            <!-- Hover variant -->
            <marker id="arrow-hover" markerWidth="22" markerHeight="22" refX="0" refY="11" orient="auto"
                markerUnits="userSpaceOnUse" viewBox="0 0 22 22">
                <path d="M0,2 L22,11 L0,20 Z" fill="#79b8ff" />
            </marker>

            <!-- Custom node variant -->
            <marker id="arrow-green" markerWidth="18" markerHeight="18" refX="0" refY="9" orient="auto"
                markerUnits="userSpaceOnUse" viewBox="0 0 18 18">
                <path d="M0,2 L18,9 L0,16 Z" fill="#3fb950" />
            </marker>
        </defs>
    </svg>

    <!-- â”€â”€ ADD NODE PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div id="add-node-panel" class="side-panel">
        <h3>Add New Node</h3>
        <div class="form-group">
            <label class="form-label" for="new-node-name">Node Name</label>
            <input class="form-input" id="new-node-name" type="text" placeholder="e.g. Social Media" />
        </div>
        <div class="form-group">
            <label class="form-label" for="connect-to-select">Connect to existing node</label>
            <select class="form-select" id="connect-to-select">
                <option value="">â€” pick a node â€”</option>
            </select>
        </div>
        <div class="form-actions">
            <button class="btn" id="cancel-node-btn">Cancel</button>
            <button class="btn primary" id="confirm-node-btn">Add Node</button>
        </div>
    </div>

    <!-- â”€â”€ ADD EDGE INSTRUCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div id="add-edge-panel" class="side-panel">
        <h3>Add Edge</h3>
        <p style="font-size:13px;color:var(--text-muted);line-height:1.5">
            Click a <strong>source</strong> node then a <strong>target</strong> node on the graph.<br /><br />
            An edge will be drawn between them. It becomes permanent in the sheet when you add a paper to it.
        </p>
        <div style="margin-top:12px" id="edge-step-indicator" style="font-size:12px;color:var(--accent)"></div>
        <div class="form-actions" style="margin-top:16px">
            <button class="btn" id="cancel-edge-btn">Cancel</button>
        </div>
    </div>

    <!-- â”€â”€ PAPER MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div id="paper-modal-overlay" class="modal-overlay">
        <div class="modal" id="paper-modal">
            <div class="modal-header">
                <div>
                    <div class="modal-title" id="modal-edge-title">Papers</div>
                    <div class="modal-subtitle" id="modal-edge-subtitle"></div>
                </div>
                <button class="modal-close" id="modal-close-btn">Ã—</button>
            </div>
            <div class="paper-list" id="paper-list"></div>

            <!-- Add paper toggle -->
            <button class="btn add-paper-toggle" id="add-paper-toggle-btn">ï¼‹ Add Paper to this Edge</button>

            <!-- Add paper form -->
            <div class="add-paper-form" id="add-paper-form">
                <div class="form-group">
                    <label class="form-label">Author(s)</label>
                    <input type="text" class="form-input" id="paper-author" placeholder="e.g. Smith, J. & Doe, A.">
                </div>
                <div class="form-row" style="display:grid; grid-template-columns: 1fr 100px; gap: 12px;">
                    <div class="form-group">
                        <label class="form-label">Journal / Source</label>
                        <input type="text" class="form-input" id="paper-journal"
                            placeholder="e.g. Nature, Political Science Quarterly">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Year</label>
                        <input type="text" class="form-input" id="paper-year" placeholder="2024">
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Relevance</label>
                    <select class="form-select" id="paper-relevance">
                        <option value="Low" selected>Low (No border)</option>
                        <option value="Medium">Medium (Thin light blue border)</option>
                        <option value="High">High (Thicker darker blue border)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Pathway</label>
                    <select class="form-select" id="paper-pathway-select"></select>
                    <input type="text" class="form-input" id="paper-pathway-new"
                        placeholder="Or type a new pathway name..." style="margin-top:8px; display:none;">
                </div>
                <div class="form-group">
                    <label class="form-label">Blurb / Abstract</label>
                    <textarea class="form-textarea" id="paper-blurb"
                        placeholder="Brief description of what this paper showsâ€¦"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">PDF File (optional)</label>
                    <label class="form-file-label">
                        <span id="file-label-text">ğŸ“„ Click to choose a PDF</span>
                        <input type="file" id="paper-file" accept=".pdf,application/pdf" />
                    </label>
                    <div id="file-name-display"></div>
                </div>
                <div class="form-actions">
                    <button class="btn" id="cancel-paper-btn">Cancel</button>
                    <button class="btn primary" id="submit-paper-btn">Upload &amp; Save</button>
                </div>
                <div id="paper-submit-status" style="font-size:12px;margin-top:8px;color:var(--text-muted)"></div>
            </div>
        </div>
    </div>

    <!-- â”€â”€ CONTRIBUTOR CHART â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div id="chart-panel">
        <h4>Papers by Contributor</h4>
        <canvas id="contrib-chart"></canvas>
        <div id="chart-empty"
            style="font-size:12px;color:var(--text-muted);text-align:center;padding:12px 0;display:none">
            No papers yet
        </div>
    </div>

    <!-- â”€â”€ STATUS BAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div id="status-bar"></div>

    <!-- â”€â”€ TOOLTIP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div id="tooltip"></div>


    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     JAVASCRIPT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script>
        // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        //  CONFIG â€” paste your deployed Apps Script URL here
        // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const CONFIG = {
            // After deploying Code.gs, paste the Web App URL here:
            APPS_SCRIPT_URL: "https://script.google.com/macros/s/AKfycbz05s-YbGypPPBykcw4ltjGhq6Sgixa1yDwmkllBFf7ltXXyE0pO9jSVs5pnl-ez2Ym/exec"
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let users = [];   // [{email, name}]
        let papers = [];   // [{startNode, endNode, user, blurb, filename}]

        // Pathway color matching
        const pathwayColorScale = d3.scaleOrdinal(d3.schemeSet2);
        function getEdgeColor(pathway) {
            return pathway ? pathwayColorScale(pathway) : "#58a6ff";
        }

        // Graph nodes list â€” fixed + custom (from localStorage)
        const FIXED_NODES = [
            { id: "Media", label: "MEDIA", fixed: true, color: "transparent", isContainer: true, baseSize: 52 },
            { id: "Media:Legacy", label: "Legacy", fixed: true, color: "#1f6feb", baseSize: 32, subnodeOf: "Media", xOffset: 0, yOffset: -26 },
            { id: "Media:Social", label: "Social", fixed: true, color: "#1f6feb", baseSize: 32, subnodeOf: "Media", xOffset: 0, yOffset: 38 },
            { id: "People", label: "People", fixed: true, color: "#1f6feb", baseSize: 32 },
            { id: "Government", label: "Government", fixed: true, color: "#1f6feb", baseSize: 32 }
        ];

        // Default edges
        const DEFAULT_EDGES = [
            { source: "Media:Legacy", target: "People", pathway: "" },
            { source: "Media:Social", target: "People", pathway: "" },
            { source: "People", target: "Government", pathway: "" }
        ];

        let customNodes = JSON.parse(localStorage.getItem("customNodes") || "[]");
        let customEdges = JSON.parse(localStorage.getItem("customEdges") || "[]");
        let nodePositions = JSON.parse(localStorage.getItem("nodePositions") || "{}");
        let hideEmptyEdges = localStorage.getItem("hideEmptyEdges") === "true";

        let currentUser = localStorage.getItem("selectedUser") || "";
        let addEdgeMode = false;
        let edgeSourceId = null;
        let activeEdge = null; // currently open modal edge {source, target}

        // â”€â”€ Chart instance
        let contribChart = null;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  UTILITIES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function showStatus(msg, ms = 3000) {
            const bar = document.getElementById("status-bar");
            bar.textContent = msg;
            bar.classList.add("show");
            clearTimeout(bar._t);
            bar._t = setTimeout(() => bar.classList.remove("show"), ms);
        }

        function edgeKey(src, tgt, pathway = "") {
            return src + "|||" + tgt + "|||" + (pathway || "Default");
        }

        function papersForEdge(src, tgt, pathway = "") {
            return papers.filter(p => p.startNode === src && p.endNode === tgt && (p.pathway || "") === (pathway || ""));
        }

        function allNodes() {
            const nodesMap = {};
            // Start with fixed nodes
            FIXED_NODES.forEach(n => {
                nodesMap[n.id] = {
                    id: n.id,
                    label: n.label,
                    color: n.color,
                    fixed: true,
                    isContainer: n.isContainer,
                    subnodeOf: n.subnodeOf
                };
            });

            // Add nodes found in papers (sync from Google Sheet)
            papers.forEach(p => {
                // If it's a fixed node by ID, we already have it. 
                if (p.startNode && !nodesMap[p.startNode]) {
                    nodesMap[p.startNode] = { id: p.startNode, label: p.startNode, fixed: false, color: "#3fb950" };
                }
                if (p.endNode && !nodesMap[p.endNode]) {
                    nodesMap[p.endNode] = { id: p.endNode, label: p.endNode, fixed: false, color: "#3fb950" };
                }
            });

            // Add custom nodes that don't have papers yet (from localStorage)
            customNodes.forEach(n => {
                if (!nodesMap[n.id]) {
                    nodesMap[n.id] = { id: n.id, label: n.label, fixed: false, color: "#3fb950" };
                }
            });

            return Object.values(nodesMap);
        }

        function allEdges() {
            const edgeMap = {};
            // 1. Default structural edges
            DEFAULT_EDGES.forEach(e => {
                const k = edgeKey(e.source, e.target, e.pathway);
                edgeMap[k] = { source: e.source, target: e.target, pathway: e.pathway || "" };
            });

            // 2. Edges implied by actual papers
            papers.forEach(p => {
                if (p.startNode && p.endNode) {
                    const k = edgeKey(p.startNode, p.endNode, p.pathway);
                    edgeMap[k] = { source: p.startNode, target: p.endNode, pathway: p.pathway || "" };
                }
            });

            // 3. User-added custom edges
            customEdges.forEach(e => {
                const k = edgeKey(e.source, e.target, e.pathway);
                edgeMap[k] = { source: e.source, target: e.target, pathway: e.pathway || "" };
            });

            const result = Object.values(edgeMap);

            // If "Hide Empty" mode is on, filter out everything with 0 papers
            if (hideEmptyEdges) {
                return result.filter(e => {
                    // Always show the edge if it has papers
                    if (papersForEdge(e.source, e.target, e.pathway).length > 0) return true;
                    return false;
                });
            }

            return result;
        }

        function nameForEmail(email) {
            const u = users.find(u => u.email === email);
            return u ? u.name : email;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  API CALLS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async function apiGet(action) {
            const url = `${CONFIG.APPS_SCRIPT_URL}?action=${action}`;
            const res = await fetch(url);
            return res.json();
        }

        async function apiPost(payload) {
            const res = await fetch(CONFIG.APPS_SCRIPT_URL, {
                method: "POST",
                body: JSON.stringify(payload),
                // text/plain avoids the CORS OPTIONS preflight that Apps Script cannot handle
                headers: { "Content-Type": "text/plain" }
            });
            return res.json();
        }

        async function loadData() {
            showStatus("Loading dataâ€¦", 10000);
            try {
                const [u, p] = await Promise.all([apiGet("getUsers"), apiGet("getPapers")]);
                users = u;

                // DATA NORMALIZATION: Map Spreadsheet "Media:X" syntax to our IDs
                papers = p.map(paper => {
                    // Support "Media:Social" -> "Media:Social" etc.
                    // Legacy support for "Legacy Media" and "Social Media" strings
                    if (paper.startNode === "Legacy Media") paper.startNode = "Media:Legacy";
                    if (paper.endNode === "Legacy Media") paper.endNode = "Media:Legacy";
                    if (paper.startNode === "Social Media") paper.startNode = "Media:Social";
                    if (paper.endNode === "Social Media") paper.endNode = "Media:Social";
                    // Legacy support for "Media" -> "Media (All)"
                    if (paper.startNode === "Media") paper.startNode = "Media";
                    if (paper.endNode === "Media") paper.endNode = "Media";
                    return paper;
                });

                showStatus("Data loaded âœ“");
                populateUserDropdown();
                renderChart();
                renderGraph();
            } catch (e) {
                showStatus("âš  Could not reach Apps Script. Check CONFIG.APPS_SCRIPT_URL", 8000);
                console.error(e);
                // Render graph with empty data so UI is still usable
                renderGraph();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  USER DROPDOWN
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function populateUserDropdown() {
            const sel = document.getElementById("user-select");
            sel.innerHTML = `<option value="">â€” select your name â€”</option>`;
            users.forEach(u => {
                const opt = document.createElement("option");
                opt.value = u.email;
                opt.textContent = u.name;
                if (u.email === currentUser) opt.selected = true;
                sel.appendChild(opt);
            });
        }

        document.getElementById("user-select").addEventListener("change", e => {
            currentUser = e.target.value;
            localStorage.setItem("selectedUser", currentUser);
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  D3 GRAPH
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const svg = d3.select("#graph-svg");
        const W = () => window.innerWidth;
        const H = () => window.innerHeight;

        // Layers
        const edgeLayer = svg.append("g").attr("class", "edge-layer");
        const labelLayer = svg.append("g").attr("class", "label-layer");
        const nodeLayer = svg.append("g").attr("class", "node-layer");

        // Zoom
        const zoom = d3.zoom().scaleExtent([0.2, 4])
            .on("zoom", (event) => {
                edgeLayer.attr("transform", event.transform);
                labelLayer.attr("transform", event.transform);
                nodeLayer.attr("transform", event.transform);
            });
        svg.call(zoom);

        // Fixed node initial positions (if not overridden by localStorage)
        function getPos(id) {
            // Force subnodes to stick tightly to their parent's coordinate
            const fixed = FIXED_NODES.find(n => n.id === id);
            if (fixed && fixed.subnodeOf) {
                const p = getPos(fixed.subnodeOf);
                return { x: p.x + fixed.xOffset, y: p.y + fixed.yOffset };
            }

            if (nodePositions[id]) return nodePositions[id];

            // Default spacing
            const w = W(), h = H();
            const defaults = {
                "Media": { x: w * 0.20, y: h * 0.40 },
                "People": { x: w * 0.50, y: h * 0.40 },
                "Government": { x: w * 0.75, y: h * 0.40 }
            };
            if (defaults[id]) return defaults[id];
            // New custom node: assign a random position and persist it immediately
            // so the node circle and its edge endpoints always use the same coordinates
            const pos = { x: 150 + Math.random() * (W() - 300), y: 150 + Math.random() * (H() - 300) };
            savePos(id, pos.x, pos.y);
            return pos;
        }

        function savePos(id, x, y) {
            nodePositions[id] = { x, y };
            localStorage.setItem("nodePositions", JSON.stringify(nodePositions));
        }

        // â”€â”€ NODE RADIUS
        function nodeRadius(id) {
            const fixed = FIXED_NODES.find(n => n.id === id);
            if (fixed) return fixed.baseSize; // Fixed nodes handle their own core size

            const count = papers.filter(p => p.startNode === id || p.endNode === id).length;
            return 32 + count * 2;
        }

        // â”€â”€ EDGE STROKE WIDTH (proportional to paper count)
        function edgeStrokeWidth(src, tgt, pathway = "") {
            const n = papersForEdge(src, tgt, pathway).length;
            return Math.max(2, 2 + n * 1.5);
        }

        // â”€â”€ Compute curved path between two nodes
        function edgePath(d, nodeMap, curvature = 0) {
            const src = d.source;
            const tgt = d.target;
            const s = nodeMap[src];
            const t = nodeMap[tgt];
            if (!s || !t) return "";

            const n = papersForEdge(src, tgt, d.pathway).length;
            let arrowLen = 14;
            if (n > 12) arrowLen = 40;
            else if (n > 7) arrowLen = 30;
            else if (n > 4) arrowLen = 24;
            else if (n > 1) arrowLen = 18;

            const sr = nodeRadius(src);
            const tr = nodeRadius(tgt);

            const dx = t.x - s.x, dy = t.y - s.y;
            const len = Math.sqrt(dx * dx + dy * dy) || 1;

            // Shift the perceived start/end centers perpendicularly based on curvature.
            // This forces curved edges bounding for the same target to physically land 
            // at different distinct points around its circumference, preventing overlaps!
            const perpX = -dy / len * (curvature * 0.7);
            const perpY = dx / len * (curvature * 0.7);

            const sxCenter = s.x + perpX;
            const syCenter = s.y + perpY;
            const txCenter = t.x + perpX;
            const tyCenter = t.y + perpY;

            if (curvature === 0) {
                const sx = s.x + dx / len * sr;
                const sy = s.y + dy / len * sr;
                const ex = txCenter - dx / len * (tr + 2 + arrowLen);
                const ey = tyCenter - dy / len * (tr + 2 + arrowLen);
                return `M${sx},${sy} L${ex},${ey}`;
            }

            // Curved arc: use tangent control points for precise boundary connections
            const mx = (s.x + txCenter) / 2;
            const my = (s.y + tyCenter) / 2;
            const nx = -dy / len * curvature;
            const ny = dx / len * curvature;
            const cx = mx + nx;
            const cy = my + ny;

            // Start vector directly toward control point
            const dsx = cx - s.x, dsy = cy - s.y;
            const slen = Math.sqrt(dsx * dsx + dsy * dsy) || 1;
            const sx = s.x + dsx / slen * sr;
            const sy = s.y + dsy / slen * sr;

            // End vector directly from control point targeting end
            const dtx = txCenter - cx, dty = tyCenter - cy;
            const tlen = Math.sqrt(dtx * dtx + dty * dty) || 1;
            const ex = txCenter - dtx / tlen * (tr + 2 + arrowLen);
            const ey = tyCenter - dty / tlen * (tr + 2 + arrowLen);

            return `M${sx},${sy} Q${cx},${cy} ${ex},${ey}`;
        }

        function edgeMidpoint(d, nodeMap, curvature = 0) {
            const s = nodeMap[d.source];
            const tp = nodeMap[d.target];
            if (!s || !tp) return { x: 0, y: 0 };

            // To prevent label overlapping entirely on closely packed long lines, we stagger t
            // based on the edge's total count in the group.
            let t = 0.5;
            if (d._groupDirTotal > 1) {
                // Stagger from 0.35 to 0.65 based on index
                const step = 0.3 / (d._groupDirTotal - 1);
                t = 0.35 + d._groupDirIdx * step;
            }

            if (curvature === 0) {
                return { x: s.x + (tp.x - s.x) * t, y: s.y + (tp.y - s.y) * t };
            }

            const dx = tp.x - s.x;
            const dy = tp.y - s.y;
            const len = Math.sqrt(dx * dx + dy * dy) || 1;

            const mx = (s.x + tp.x) / 2;
            const my = (s.y + tp.y) / 2;
            const cx = mx - (dy / len) * curvature;
            const cy = my + (dx / len) * curvature;

            // Bezier curve formula B(t) = (1-t)^2 P0 + 2(1-t)t P1 + t^2 P2
            const u = 1 - t;
            const x = u * u * s.x + 2 * u * t * cx + t * t * tp.x;
            const y = u * u * s.y + 2 * u * t * cy + t * t * tp.y;
            return { x, y };
        }

        function renderGraph() {
            const nodes = allNodes();
            const edges = allEdges();
            const nodeMap = {};
            nodes.forEach(n => {
                const p = getPos(n.id);
                nodeMap[n.id] = { x: p.x, y: p.y };
            });

            // â”€â”€ DYNAMIC MARKERS (Colors & Sizes)
            const SIZES = [
                { id: "xs", len: 14, refY: 7, path: "M0,2 L14,7 L0,12 Z" },
                { id: "s", len: 18, refY: 9, path: "M0,2 L18,9 L0,16 Z" },
                { id: "m", len: 24, refY: 12, path: "M0,2 L24,12 L0,22 Z" },
                { id: "l", len: 30, refY: 15, path: "M0,1 L30,15 L0,29 Z" },
                { id: "xl", len: 40, refY: 20, path: "M0,0 L40,20 L0,40 Z" }
            ];

            const defs = svg.select("defs");
            const pathwayGroups = ["", ...new Set(edges.map(e => String(e.pathway || "")).filter(p => p))];
            const markerData = [];
            pathwayGroups.forEach(p => {
                const color = getEdgeColor(p);
                const prefix = p ? `arrow-${String(p).replace(/[^a-zA-Z0-9]/g, '-')}-` : "arrow-";
                SIZES.forEach(s => {
                    markerData.push({ id: `${prefix}${s.id}`, size: s, color: color });
                });
            });

            const markerSel = defs.selectAll("marker.dynamic-marker").data(markerData, d => d.id);
            const markerEnter = markerSel.enter().append("marker")
                .attr("class", "dynamic-marker")
                .attr("id", d => d.id)
                .attr("markerWidth", d => d.size.len)
                .attr("markerHeight", d => d.size.len)
                .attr("refX", 0)
                .attr("refY", d => d.size.refY)
                .attr("orient", "auto")
                .attr("markerUnits", "userSpaceOnUse")
                .attr("viewBox", d => `0 0 ${d.size.len} ${d.size.len}`);

            markerEnter.append("path")
                .attr("d", d => d.size.path);

            const markerMerged = markerEnter.merge(markerSel);
            markerMerged.select("path").attr("fill", d => d.color);
            markerSel.exit().remove();

            // â”€â”€ EDGES
            const edgeSel = edgeLayer.selectAll("path.edge-path")
                .data(edges, d => edgeKey(d.source, d.target, d.pathway));

            // Figure out which edges are "reverse pairs" and need curvature
            const edgeSet = new Set(edges.map(e => edgeKey(e.source, e.target, e.pathway)));

            // Group edges by parent-pair
            const dirGroupEdges = {};
            const undirGroupCounts = {};

            edges.forEach(e => {
                const sNode = nodes.find(n => n.id === e.source);
                const tNode = nodes.find(n => n.id === e.target);
                const sParent = (sNode && sNode.subnodeOf) ? sNode.subnodeOf : e.source;
                const tParent = (tNode && tNode.subnodeOf) ? tNode.subnodeOf : e.target;

                const dirKey = `${sParent}->${tParent}`;
                if (!dirGroupEdges[dirKey]) dirGroupEdges[dirKey] = [];
                dirGroupEdges[dirKey].push(e);

                const undirKey = [sParent, tParent].sort().join("<>");
                if (!undirGroupCounts[undirKey]) undirGroupCounts[undirKey] = new Set();
                undirGroupCounts[undirKey].add(dirKey);
            });

            for (const k in dirGroupEdges) {
                const arr = dirGroupEdges[k];
                if (arr.length === 0) continue;

                // Get general direction of this group using the first edge
                const firstEdge = arr[0];
                const pseudoSNode = nodeMap[firstEdge.source] || { x: 0, y: 0 };
                const pseudoTNode = nodeMap[firstEdge.target] || { x: 0, y: 0 };
                const dx = pseudoTNode.x - pseudoSNode.x;
                const dy = pseudoTNode.y - pseudoSNode.y;

                // Sort by geometric position normal to the path so lines don't tangle
                arr.sort((a, b) => {
                    const aS = nodes.find(n => n.id === a.source);
                    const bS = nodes.find(n => n.id === b.source);
                    const aT = nodes.find(n => n.id === a.target);
                    const bT = nodes.find(n => n.id === b.target);

                    const aSX = (aS && aS.xOffset) ? aS.xOffset : 0;
                    const aSY = (aS && aS.yOffset) ? aS.yOffset : 0;
                    const bSX = (bS && bS.xOffset) ? bS.xOffset : 0;
                    const bSY = (bS && bS.yOffset) ? bS.yOffset : 0;

                    const aTX = (aT && aT.xOffset) ? aT.xOffset : 0;
                    const aTY = (aT && aT.yOffset) ? aT.yOffset : 0;
                    const bTX = (bT && bT.xOffset) ? bT.xOffset : 0;
                    const bTY = (bT && bT.yOffset) ? bT.yOffset : 0;

                    const aX = aSX + aTX, aY = aSY + aTY;
                    const bX = bSX + bTX, bY = bSY + bTY;

                    const aDot = aX * (-dy) + aY * dx;
                    const bDot = bX * (-dy) + bY * dx;
                    return aDot - bDot;
                });

                arr.forEach((e, i) => {
                    e._groupDirIdx = i;
                    e._groupDirTotal = arr.length;
                    const sNode = nodes.find(n => n.id === e.source);
                    const tNode = nodes.find(n => n.id === e.target);
                    const sParent = (sNode && sNode.subnodeOf) ? sNode.subnodeOf : e.source;
                    const tParent = (tNode && tNode.subnodeOf) ? tNode.subnodeOf : e.target;
                    const undirKey = [sParent, tParent].sort().join("<>");
                    e._isGroupBidirectional = undirGroupCounts[undirKey] && undirGroupCounts[undirKey].size > 1;
                });
            }

            function getCurvature(e) {
                const total = e._groupDirTotal || 1;
                const idx = e._groupDirIdx || 0;

                const sNode = nodes.find(n => n.id === e.source);
                const tNode = nodes.find(n => n.id === e.target);
                const sParent = (sNode && sNode.subnodeOf) ? sNode.subnodeOf : e.source;
                const tParent = (tNode && tNode.subnodeOf) ? tNode.subnodeOf : e.target;
                const sameParent = (sParent === tParent);

                let base = 0;

                if (sameParent) {
                    base = -80; // Powerful outward arc over the top bounding boxes
                } else {
                    // Start by forcing paths to arc cleanly to the "right" of their travel direction.
                    // This elegantly separates A->B and B->A logic instantly forming roundabout highway cycles.
                    if (e._isGroupBidirectional) {
                        // Separate strongly. Spread them from +35 to +75 (if grouped)
                        let spread = 40;
                        base = 35 + (total > 1 ? (idx * (spread / (total - 1))) : 0);
                    } else if (total > 1) {
                        // Bundle is unidirectional but thick. Spread symmetrically around the axis.
                        let spread = 140; // Widened from 80
                        base = -spread / 2 + (idx * (spread / (total - 1)));
                    } else {
                        // Single edge unidirectional. Maintain natural subnode offset bow.
                        let bow = 0;
                        const s = nodeMap[e.source];
                        const t = nodeMap[e.target];
                        if (s && t) {
                            const dx = t.x - s.x;
                            const dy = t.y - s.y;
                            const len = Math.sqrt(dx * dx + dy * dy) || 1;
                            const nx = -dy / len;
                            const ny = dx / len;

                            if (sNode && sNode.subnodeOf) {
                                const dot = (sNode.xOffset || 0) * nx + (sNode.yOffset || 0) * ny;
                                bow += dot * 2.5; // Amplified from 1.5
                            }
                            if (tNode && tNode.subnodeOf) {
                                const dot = (tNode.xOffset || 0) * nx + (tNode.yOffset || 0) * ny;
                                bow += dot * 2.5; // Amplified from 1.5
                            }
                        }
                        // If no subnode offset, give a tiny default bow to avoid visual overlaps with nodes on the line
                        if (Math.abs(bow) < 12) bow = (bow < 0 ? -12 : 12);
                        base = bow;
                    }
                }
                return base;
            }

            // Memoize curvatures for labels
            edges.forEach(e => e._curvature = getCurvature(e));

            edgeSel.enter().append("path")
                .attr("class", "edge-path")
                .attr("marker-end", d => {
                    const n = papersForEdge(d.source, d.target, d.pathway).length;
                    const pStr = d.pathway ? String(d.pathway) : "";
                    const prefix = pStr ? `arrow-${pStr.replace(/[^a-zA-Z0-9]/g, '-')}-` : "arrow-";
                    if (n > 12) return `url(#${prefix}xl)`;
                    if (n > 7) return `url(#${prefix}l)`;
                    if (n > 4) return `url(#${prefix}m)`;
                    if (n > 1) return `url(#${prefix}s)`;
                    return `url(#${prefix}xs)`;
                })
                .on("click", function (event, d) {
                    if (addEdgeMode) return;
                    openModal(d.source, d.target, d.pathway);
                })
                .on("mouseenter", function (event, d) {
                    const tip = document.getElementById("tooltip");
                    const n = papersForEdge(d.source, d.target, d.pathway).length;
                    const pathTxt = d.pathway ? ` via ${d.pathway}` : "";
                    tip.textContent = `${d.source} â†’ ${d.target}${pathTxt} (${n} paper${n !== 1 ? "s" : ""})`;
                    tip.style.display = "block";
                })
                .on("mousemove", function (event) {
                    const tip = document.getElementById("tooltip");
                    tip.style.left = (event.clientX + 14) + "px";
                    tip.style.top = (event.clientY - 20) + "px";
                })
                .on("mouseleave", function () {
                    document.getElementById("tooltip").style.display = "none";
                })
                .merge(edgeSel)
                .attr("stroke", d => getEdgeColor(d.pathway))
                .attr("d", d => edgePath(d, nodeMap, d._curvature))
                .attr("stroke-width", d => edgeStrokeWidth(d.source, d.target, d.pathway));

            edgeSel.exit().remove();

            // â”€â”€ EDGE LABELS (Removed at user request, now hover only)
            labelLayer.selectAll("text.edge-label").remove();

            // â”€â”€ NODES
            const nodeSel = nodeLayer.selectAll("g.node-g")
                .data(nodes, d => d.id);

            const nodeEnter = nodeSel.enter().append("g")
                .attr("class", "node-g")
                .attr("transform", d => {
                    const p = getPos(d.id);
                    return `translate(${p.x},${p.y})`;
                });

            // Fixed nodes are squares, custom nodes are circles
            nodeEnter.each(function (d) {
                const g = d3.select(this);
                if (d.isContainer) {
                    g.append("rect")
                        .attr("class", "node-shape group-rect")
                        .attr("fill", "rgba(31, 111, 235, 0.05)")
                        .attr("stroke", "#1f6feb")
                        .attr("stroke-dasharray", "4")
                        .attr("stroke-width", "1.5")
                        .attr("pointer-events", "all"); // Allow clicks exactly like other nodes
                } else if (d.fixed) {
                    g.append("rect")
                        .attr("class", "node-shape")
                        .attr("fill", d.color)
                        .attr("stroke", d3.color(d.color).brighter(0.5))
                        .attr("stroke-width", 2.5);
                } else {
                    g.append("circle")
                        .attr("class", "node-shape")
                        .attr("fill", d.color)
                        .attr("stroke", d3.color(d.color).brighter(0.5))
                        .attr("stroke-width", 2.5);
                }
            });

            nodeEnter.append("text")
                .attr("class", "node-label")
                .text(d => d.label);

            const nodeMerged = nodeEnter.merge(nodeSel);

            nodeMerged.select(".node-label")
                .each(function (d) {
                    const txt = d3.select(this);
                    if (d.isContainer) {
                        txt.attr("x", -35)
                            .attr("y", -62)
                            .style("text-anchor", "start")
                            .style("font-size", "13px")
                            .style("font-weight", "700")
                            .style("text-transform", "uppercase")
                            .style("letter-spacing", "0.5px")
                            .style("fill", "#1f6feb");
                    } else if (d.fixed) {
                        txt.attr("x", 0)
                            .attr("y", 4) // Center vertically inside the square
                            .style("text-anchor", "middle")
                            .style("font-size", "11px")
                            .style("font-weight", "600")
                            .style("fill", "#ffffff"); // White font
                    } else {
                        txt.attr("x", 0)
                            .attr("y", 4) // Center vertically inside the circle
                            .style("text-anchor", "middle")
                            .style("font-size", "11px") // Matches square labels
                            .style("font-weight", "600")
                            .style("fill", "#ffffff") // White font
                            .style("text-transform", "")
                            .style("letter-spacing", "");
                    }
                });

            nodeMerged.select(".node-shape")
                .each(function (d) {
                    const shape = d3.select(this);
                    if (d.isContainer) {
                        const width = 70;
                        const height = 130;
                        shape.attr("width", width).attr("height", height)
                            .attr("x", -width / 2).attr("y", -height / 2 + 6)
                            .attr("rx", 10);
                    } else {
                        const r = nodeRadius(d.id);
                        if (d.fixed) {
                            const size = r * 1.6; // Slightly smaller visual footprint than circles
                            shape.attr("width", size).attr("height", size)
                                .attr("x", -size / 2).attr("y", -size / 2)
                                .attr("rx", 4); // Subtle rounded corners
                        } else {
                            shape.attr("r", r);
                        }
                    }
                });

            // Drag handling (Lock groups together natively)
            nodeMerged.call(
                d3.drag()
                    .on("drag", function (event, d) {
                        if (addEdgeMode) return;

                        // 1. Enforce parent movement: If a subnode is dragged, redirect to dragging its parent container
                        const targetId = d.subnodeOf ? d.subnodeOf : d.id;

                        // 2. Update parent position
                        const p = getPos(targetId);
                        const nx = p.x + event.dx;
                        const ny = p.y + event.dy;
                        savePos(targetId, nx, ny);
                        nodePositions[targetId] = { x: nx, y: ny }; // update memory immediately

                        // 3. Move parent and all its subnodes visually
                        const toUpdate = [targetId, ...nodes.filter(n => n.subnodeOf === targetId).map(n => n.id)];
                        toUpdate.forEach(id => { nodeMap[id] = getPos(id); }); // Re-fetch locked child positions

                        nodeLayer.selectAll("g.node-g")
                            .filter(n => toUpdate.includes(n.id))
                            .attr("transform", n => `translate(${nodeMap[n.id].x},${nodeMap[n.id].y})`);

                        // 4. Update Edges
                        renderEdgesOnly(edges, nodeMap);
                    })
            );

            // Node click in add-edge mode
            nodeMerged.on("click", function (event, d) {
                if (!addEdgeMode) return;
                event.stopPropagation();
                if (!edgeSourceId) {
                    edgeSourceId = d.id;
                    d3.select(this).select(".node-shape").attr("stroke", "#3fb950").attr("stroke-width", 4);
                    document.getElementById("edge-step-indicator").textContent = `Source: ${d.label} â€” now click target`;
                } else if (edgeSourceId !== d.id) {
                    const src = edgeSourceId;
                    const tgt = d.id;
                    // Avoid duplicate
                    if (!edges.find(e => e.source === src && e.target === tgt)) {
                        customEdges.push({ source: src, target: tgt });
                        localStorage.setItem("customEdges", JSON.stringify(customEdges));
                        showStatus(`Edge added: ${src} â†’ ${tgt}`);
                    } else {
                        showStatus("Edge already exists");
                    }
                    cancelEdgeMode();
                    renderGraph();
                }
            });

            nodeSel.exit().remove();
        }

        function renderEdgesOnly(edges, nodeMap) {
            // Use the pre-calculated curvature stored in d._curvature from renderGraph
            edgeLayer.selectAll("path.edge-path")
                .attr("d", d => edgePath(d, nodeMap, d._curvature || 0));
            labelLayer.selectAll("text.edge-label")
                .each(function (d) {
                    const mid = edgeMidpoint(d, nodeMap, d._curvature || 0);

                    const s = nodeMap[d.source];
                    const t = nodeMap[d.target];
                    if (!s || !t) return;

                    const dx = t.x - s.x, dy = t.y - s.y;

                    let angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    if (angle > 90 || angle < -90) angle += 180;

                    d3.select(this)
                        .attr("x", mid.x)
                        .attr("y", mid.y)
                        .attr("transform", `rotate(${angle}, ${mid.x}, ${mid.y}) translate(0, -6)`);
                });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  PAPER MODAL
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function openModal(src, tgt, pathway = "") {
            activeEdge = { source: src, target: tgt, pathway: pathway };
            const title = document.getElementById("modal-edge-title");
            title.textContent = `${src} â†’ ${tgt}`;
            if (pathway) title.textContent += ` (${pathway})`;

            document.getElementById("modal-edge-subtitle").textContent =
                `${papersForEdge(src, tgt, pathway).length} paper(s) collected`;

            // Reset and Close the "Add Paper" form if it was open
            closeAddPaperForm();
            renderPaperList(src, tgt, pathway);
            populatePathwayDropdown();

            document.getElementById("paper-modal-overlay").classList.add("open");
        }

        function populatePathwayDropdown() {
            const select = document.getElementById("paper-pathway-select");
            const existingPathways = [...new Set(papers.map(p => p.pathway).filter(p => p))];

            let html = `<option value="">Default / None</option>`;
            existingPathways.sort().forEach(p => {
                html += `<option value="${p}">${p}</option>`;
            });
            html += `<option value="NEW">+ Add New Pathway...</option>`;
            select.innerHTML = html;

            // Set current pathway if we opened from a specific one
            if (activeEdge && activeEdge.pathway) {
                select.value = activeEdge.pathway;
            } else {
                select.value = "";
            }

            toggleNewPathwayInput();
        }

        function toggleNewPathwayInput() {
            const select = document.getElementById("paper-pathway-select");
            const input = document.getElementById("paper-pathway-new");
            input.style.display = (select.value === "NEW") ? "block" : "none";
        }

        document.getElementById("paper-pathway-select").addEventListener("change", toggleNewPathwayInput);

        function renderPaperList(src, tgt, pathway = "") {
            const list = document.getElementById("paper-list");
            const ps = papersForEdge(src, tgt, pathway);

            if (ps.length === 0) {
                list.innerHTML = `<div class="paper-empty">No papers yet for this edge.<br/>Be the first to add one!</div>`;
                return;
            }

            list.innerHTML = ps.map((p, i) => {
                // Determine the best PDF ID (support both new driveId column and older data where ID was in filename)
                let bestId = p.driveId;
                if (!bestId && p.filename && !p.filename.includes('.') && p.filename.length > 20) {
                    bestId = p.filename;
                }

                return `
    <div class="paper-card">
      <div class="paper-card-blurb relevance-${p.relevance || 'Low'}">${escHtml(p.blurb) || "<em style='color:var(--text-muted)'>No blurb provided</em>"}</div>
      <div class="paper-card-meta">
        ${(p.author || p.year || p.journal) ? `
          <div style="font-weight:600; margin-bottom:4px; font-size:13px;">
            ${escHtml(p.author)}${p.year ? ` (${escHtml(p.year)})` : ""}${p.journal ? ` â€” <em>${escHtml(p.journal)}</em>` : ""}
          </div>
        ` : ""}
        <div style="display:flex; justify-content:space-between; align-items:center; width:100%; font-size:12px;">
          <span>ğŸ‘¤ ${escHtml(nameForEmail(p.user)) || escHtml(p.user)}</span>
          ${bestId
                        ? `<a href="https://drive.google.com/file/d/${escHtml(bestId)}/view" target="_blank" rel="noopener">ğŸ“„ View PDF</a>`
                        : (p.filename ? `<span style="color:var(--text-muted)">ğŸ“ ${escHtml(p.filename)}</span>` : "")}
        </div>
      </div>
    </div>
  `;
            }).join("");
        }

        function escHtml(s) {
            if (!s) return "";
            return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
        }

        function closeModal() {
            document.getElementById("paper-modal-overlay").classList.remove("open");
            activeEdge = null;
        }

        document.getElementById("modal-close-btn").addEventListener("click", closeModal);
        document.getElementById("paper-modal-overlay").addEventListener("click", e => {
            if (e.target === document.getElementById("paper-modal-overlay")) closeModal();
        });

        // â”€â”€ Add paper toggle
        document.getElementById("add-paper-toggle-btn").addEventListener("click", () => {
            if (!currentUser) { showStatus("Please select your name first (top-right)"); return; }
            const form = document.getElementById("add-paper-form");
            form.classList.toggle("open");
            document.getElementById("add-paper-toggle-btn").textContent =
                form.classList.contains("open") ? "âœ• Cancel" : "ï¼‹ Add Paper to this Edge";
        });

        function closeAddPaperForm() {
            document.getElementById("add-paper-form").classList.remove("open");
            document.getElementById("add-paper-toggle-btn").textContent = "ï¼‹ Add Paper to this Edge";
            document.getElementById("paper-blurb").value = "";
            document.getElementById("paper-file").value = "";
            document.getElementById("file-name-display").textContent = "";
            document.getElementById("paper-submit-status").textContent = "";
        }

        document.getElementById("cancel-paper-btn").addEventListener("click", closeAddPaperForm);

        // File input display
        document.getElementById("paper-file").addEventListener("change", e => {
            const f = e.target.files[0];
            document.getElementById("file-name-display").textContent = f ? `Selected: ${f.name}` : "";
        });

        // â”€â”€ Submit paper
        document.getElementById("submit-paper-btn").addEventListener("click", async () => {
            if (!activeEdge) return;
            if (!currentUser) { showStatus("Please select your name first"); return; }

            const author = document.getElementById("paper-author").value.trim();
            const journal = document.getElementById("paper-journal").value.trim();
            const year = document.getElementById("paper-year").value.trim();
            const relevance = document.getElementById("paper-relevance").value;

            let pathway = document.getElementById("paper-pathway-select").value;
            if (pathway === "NEW") {
                pathway = document.getElementById("paper-pathway-new").value.trim();
            }

            const blurb = document.getElementById("paper-blurb").value.trim();
            const fileEl = document.getElementById("paper-file");
            const file = fileEl.files[0];
            const statusEl = document.getElementById("paper-submit-status");

            if (!blurb && !file && !author) { statusEl.textContent = "Please add at least an author, a blurb, or a PDF file."; return; }

            const btn = document.getElementById("submit-paper-btn");
            btn.disabled = true;
            btn.textContent = "Uploadingâ€¦";
            statusEl.textContent = "";

            try {
                let fileData = "";
                let mimeType = "application/pdf";
                let filename = "";

                if (file) {
                    mimeType = file.type || "application/pdf";
                    filename = file.name;
                    fileData = await readFileAsBase64(file);
                }

                const payload = {
                    action: "addPaper",
                    startNode: activeEdge.source,
                    endNode: activeEdge.target,
                    user: currentUser,
                    blurb: blurb,
                    author: author,
                    journal: journal,
                    year: year,
                    relevance: relevance,
                    pathway: pathway,
                    filename: filename,       // Original name (e.g. "Paper.pdf")
                    fileData: fileData,
                    mimeType: mimeType
                };

                const res = await apiPost(payload);
                if (res.error) throw new Error(res.error);

                // Update local state
                papers.push({
                    startNode: activeEdge.source,
                    endNode: activeEdge.target,
                    user: currentUser,
                    blurb: blurb,
                    author: author,
                    journal: journal,
                    year: year,
                    relevance: relevance,
                    pathway: pathway,
                    filename: filename,       // Original name (e.g. "Paper.pdf")
                    driveId: res.driveFileId  // Internal ID for linking
                });

                // Update the edge's pathway if it was previously empty
                if (!activeEdge.pathway && pathway) {
                    activeEdge.pathway = pathway;
                    // Find it in customEdges and update so the graph gets the color
                    const cIdx = customEdges.findIndex(e => e.source === activeEdge.source && e.target === activeEdge.target && !e.pathway);
                    if (cIdx !== -1) {
                        customEdges[cIdx].pathway = pathway;
                        saveLocal();
                    }
                }

                renderPaperList(activeEdge.source, activeEdge.target, activeEdge.pathway);
                document.getElementById("modal-edge-subtitle").textContent =
                    `${papersForEdge(activeEdge.source, activeEdge.target, activeEdge.pathway).length} paper(s) collected`;
                populatePathwayDropdown(); // Refresh dropdown in case "NEW" was added

                // Reset form
                document.getElementById("paper-author").value = "";
                document.getElementById("paper-journal").value = "";
                document.getElementById("paper-year").value = "";
                document.getElementById("paper-pathway-select").value = "";
                document.getElementById("paper-pathway-new").value = "";
                document.getElementById("paper-pathway-new").style.display = "none";
                document.getElementById("paper-relevance").value = "Low";
                document.getElementById("paper-blurb").value = "";
                document.getElementById("paper-file").value = "";
                document.getElementById("file-name-display").textContent = "";
                closeAddPaperForm();
                renderGraph();
                renderChart();
                showStatus("Paper added successfully âœ“");
            } catch (e) {
                statusEl.textContent = "Error: " + e.message;
                console.error(e);
            } finally {
                btn.disabled = false;
                btn.textContent = "Upload & Save";
            }
        });

        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(",")[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  ADD NODE PANEL
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        document.getElementById("add-node-btn").addEventListener("click", () => {
            closePanels();
            // Populate connect-to dropdown
            const sel = document.getElementById("connect-to-select");
            sel.innerHTML = `<option value="">â€” pick a node â€”</option>`;
            allNodes().forEach(n => {
                const opt = document.createElement("option");
                opt.value = n.id; opt.textContent = n.label;
                sel.appendChild(opt);
            });
            document.getElementById("add-node-panel").classList.add("open");
        });

        document.getElementById("cancel-node-btn").addEventListener("click", closePanels);

        document.getElementById("confirm-node-btn").addEventListener("click", () => {
            const name = document.getElementById("new-node-name").value.trim();
            const connectTo = document.getElementById("connect-to-select").value;
            if (!name) { showStatus("Please enter a node name"); return; }
            if (!connectTo) { showStatus("Please select a node to connect to"); return; }

            const id = name; // use label as ID
            if (allNodes().find(n => n.id === id)) { showStatus("A node with that name already exists"); return; }

            customNodes.push({ id, label: name });
            localStorage.setItem("customNodes", JSON.stringify(customNodes));

            customEdges.push({ source: connectTo, target: id });
            localStorage.setItem("customEdges", JSON.stringify(customEdges));

            // Calculate relative position (Suggestion 2)
            const parentPos = getPos(connectTo);
            const newX = parentPos.x + 150;
            const newY = parentPos.y + (Math.random() * 100 - 50); // +/- 50px jitter
            savePos(id, newX, newY);

            document.getElementById("new-node-name").value = "";
            closePanels();
            renderGraph();
            showStatus(`Node "${name}" added and connected to "${connectTo}"`);
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  ADD EDGE MODE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        document.getElementById("add-edge-btn").addEventListener("click", () => {
            if (addEdgeMode) { cancelEdgeMode(); return; }
            closePanels();
            addEdgeMode = true;
            edgeSourceId = null;
            document.getElementById("add-edge-btn").classList.add("active");
            document.getElementById("add-edge-panel").classList.add("open");
            document.getElementById("edge-step-indicator").textContent = "Click a source nodeâ€¦";
        });

        document.getElementById("cancel-edge-btn").addEventListener("click", cancelEdgeMode);

        function cancelEdgeMode() {
            addEdgeMode = false;
            edgeSourceId = null;
            document.getElementById("add-edge-btn").classList.remove("active");
            document.getElementById("add-edge-panel").classList.remove("open");
            // Reset highlighted node strokes
            nodeLayer.selectAll("g.node-g").select(".node-shape")
                .attr("stroke", function () {
                    const d = d3.select(this.parentNode).datum();
                    return d && d.color ? d3.color(d.color).brighter(0.5) : "#fff";
                })
                .attr("stroke-width", 2.5);
        }

        // â”€â”€ RESET CUSTOM NODES / CLEAN GRAPH
        document.getElementById("reset-graph-btn").addEventListener("click", () => {
            if (!confirm("Clean Graph? This will hide all empty edges and remove custom nodes that don't have papers yet.")) return;

            const paperNodeIds = new Set();
            papers.forEach(p => {
                if (p.startNode) paperNodeIds.add(p.startNode);
                if (p.endNode) paperNodeIds.add(p.endNode);
            });

            // Remove unused custom nodes from storage
            const removedNodeIds = new Set();
            customNodes = customNodes.filter(n => {
                if (paperNodeIds.has(n.id)) return true;
                removedNodeIds.add(n.id);
                return false;
            });

            // Enable Hide Empty Edges mode
            hideEmptyEdges = true;
            localStorage.setItem("hideEmptyEdges", "true");

            // Purge unused positions
            removedNodeIds.forEach(id => delete nodePositions[id]);

            // Persist
            localStorage.setItem("customNodes", JSON.stringify(customNodes));
            localStorage.setItem("nodePositions", JSON.stringify(nodePositions));

            // Reload visual
            nodeLayer.selectAll("*").remove();
            edgeLayer.selectAll("*").remove();
            labelLayer.selectAll("*").remove();
            renderGraph();

            showStatus(`Graph cleaned: Hidden empty edges and removed ${removedNodeIds.size} unused custom node(s) âœ“`);
        });

        function closePanels() {
            document.getElementById("add-node-panel").classList.remove("open");
            document.getElementById("add-edge-panel").classList.remove("open");
            if (addEdgeMode) cancelEdgeMode();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  CONTRIBUTOR BAR CHART
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function renderChart() {
            const counts = {};
            papers.forEach(p => {
                const name = nameForEmail(p.user) || p.user || "Unknown";
                counts[name] = (counts[name] || 0) + 1;
            });

            const labels = Object.keys(counts);
            const values = Object.values(counts);

            const emptyEl = document.getElementById("chart-empty");

            if (labels.length === 0) {
                emptyEl.style.display = "block";
                if (contribChart) { contribChart.destroy(); contribChart = null; }
                return;
            }
            emptyEl.style.display = "none";

            const ctx = document.getElementById("contrib-chart").getContext("2d");
            if (contribChart) contribChart.destroy();

            contribChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels,
                    datasets: [{
                        data: values,
                        backgroundColor: labels.map((_, i) =>
                            ["#58a6ff", "#bc8cff", "#3fb950", "#f0883e", "#e3b341"][i % 5]),
                        borderRadius: 5,
                        borderSkipped: false
                    }]
                },
                options: {
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: ctx => ` ${ctx.raw} paper${ctx.raw !== 1 ? "s" : ""}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: "#8b949e", font: { family: "Inter", size: 11 } },
                            grid: { color: "#21262d" }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: { stepSize: 1, color: "#8b949e", font: { family: "Inter", size: 11 } },
                            grid: { color: "#21262d" }
                        }
                    }
                }
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  RESIZE HANDLER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let resizeTimer;
        window.addEventListener("resize", () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(renderGraph, 200);
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  INIT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        loadData();
    </script>
</body>

</html>